initSidebarItems({"enum":[["Abi",""],["AttrStyle","Distinguishes between Attributes that decorate items and Attributes that are contained as statements within items. These two cases need to be distinguished for pretty-printing."],["BinOp",""],["BinOpToken",""],["BindingMode",""],["Body","Body of a derived struct or enum."],["CaptureBy","A capture clause"],["ConstExpr",""],["Constness",""],["Defaultness",""],["DelimToken","A delimiter token"],["ExprKind",""],["FloatTy",""],["FnArg","An argument in a function header."],["ForeignItemKind","An item within an `extern` block"],["FunctionRetTy",""],["ImplItemKind",""],["ImplPolarity",""],["IntTy",""],["ItemKind",""],["Lit","Literal kind."],["MacStmtStyle","How a macro was invoked."],["MetaItem","A compile-time attribute item."],["Mutability",""],["NestedMetaItem","Possible values inside of compile-time attribute lists."],["Pat",""],["PathParameters","Parameters of a path segment."],["RangeLimits","Limit types of a range (inclusive or exclusive)"],["Stmt","A statement, usually ending in a semicolon."],["StrStyle",""],["Token",""],["TokenTree","When the main rust parser encounters a syntax-extension invocation, it parses the arguments to the invocation as a token-tree. This is a very loose structure, such that all sorts of different AST-fragments can be passed to syntax extensions using a uniform type."],["TraitBoundModifier","A modifier on a bound, currently this is only used for `?Sized`, where the modifier is `Maybe`. Negative bounds should also be handled here."],["TraitItemKind",""],["Ty","The different kinds of types recognized by the compiler"],["TyParamBound","The AST represents all type param bounds as types. `typeck::collect::compute_bounds` matches these against the \"special\" built-in traits (see `middle::lang_items`) and detects Copy, Send and Sync."],["UnOp",""],["Unsafety",""],["VariantData","Data stored within an enum variant or struct."],["ViewPath",""],["Visibility","Visibility level of an item."],["WherePredicate","A single predicate in a `where` clause"]],"fn":[["parse_crate",""],["parse_derive_input",""],["parse_expr",""],["parse_ident",""],["parse_inner_attr",""],["parse_item",""],["parse_items",""],["parse_outer_attr",""],["parse_path",""],["parse_token_trees",""],["parse_ty_param_bound",""],["parse_type",""],["parse_where_clause",""]],"mod":[["parse","This module contains a set of exported nom parsers which can be used to parse custom grammars when used alongside the `synom` crate."],["visit","AST walker. Each overridden visit method has full control over what happens with its node, it can do its own traversal of the node's children, call `visit::walk_*` to apply the default traversal algorithm, or prevent deeper traversal by doing nothing."]],"struct":[["AngleBracketedParameterData","A path like `Foo<'a, T>`"],["Arm","An arm of a 'match'."],["Attribute","Doc-comments are promoted to attributes that have `is_sugared_doc` = true"],["BareFnArg","An argument in a function type."],["BareFnTy",""],["Block","A Block (`{ .. }`)."],["ByteStrLit",""],["Crate",""],["Delimited",""],["DeriveInput","Struct or enum sent to a `proc_macro_derive` macro."],["Expr","An expression."],["Field","A field of a struct or enum variant."],["FieldPat","A single field in a struct pattern"],["FieldValue","A field-value pair in a struct literal."],["FloatLit",""],["FnDecl","Header (not the body) of a function declaration."],["ForeignItem",""],["ForeignMod","Foreign module declaration."],["Generics","Represents lifetimes and type parameters attached to a declaration of a function, enum, trait, etc."],["Ident",""],["ImplGenerics","Returned by `Generics::split_for_impl`."],["ImplItem",""],["IntLit",""],["Item","An item"],["Lifetime",""],["LifetimeDef","A lifetime definition, e.g. `'a: 'b+'c+'d`"],["Local","Local represents a `let` statement, e.g., `let <pat>:<ty> = <expr>;`"],["Mac","Represents a macro invocation. The Path indicates which macro is being invoked, and the vector of token-trees contains the source of the macro invocation."],["MethodSig","Represents a method's signature in a trait declaration, or in an implementation."],["MutTy",""],["ParenthesizedParameterData","A path like `Foo(A,B) -> C`"],["Path","A \"Path\" is essentially Rust's notion of a name."],["PathListItem",""],["PathSegment","A segment of a path: an identifier, an optional lifetime, and a set of types."],["PolyTraitRef",""],["QSelf","The explicit Self type in a \"qualified path\". The actual path, including the trait and the associated item, is stored separately. `position` represents the index of the associated item qualified with this Self type."],["StrLit",""],["TraitItem","Represents an item declaration within a trait declaration, possibly including a default implementation. A trait item is either required (meaning it doesn't have an implementation, just a signature) or provided (meaning it has a default implementation)."],["Turbofish","Returned by `TyGenerics::as_turbofish`."],["TyGenerics","Returned by `Generics::split_for_impl`."],["TyParam","A generic type parameter, e.g. `T: Into<String>`."],["TypeBinding","Bind a type to an associated type: `A=Foo`."],["Variant","An enum variant."],["WhereBoundPredicate","A type bound."],["WhereClause","A `where` clause in a definition"],["WhereEqPredicate","An equality predicate (unsupported)."],["WhereRegionPredicate","A lifetime predicate."]]});